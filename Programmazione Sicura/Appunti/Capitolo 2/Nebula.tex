\chapter{Nebula}
Nebula è la prima macchina virtuale che studieremo in questo corso. Ci sono diversi livelli, noi affronteremo le sfide:
\begin{itemize}
    \item Nebula 00
    \item Nebula 01
    \item Nebula 02
    \item Nebula 04
    \item Nebula 07
    \item Nebula 10
    \item Nebula 13
\end{itemize}
La macchina virtuale è scaricabile dal sito \href{https://exploit.education/}{Exploit Education}.
Le sfide di nebula trattano l'iniezione locale e remota di codice.

Ogni macchina ha tre account:
\begin{itemize}
    \item \textcolor{red}{Giocatore}, un utente con il ruolo di attaccante che può accedere con la coppia di credenziali:
    \begin{itemize}
        \item username: levelN(N=00,01,02,ecc.)
        \item password: levelN
    \end{itemize}
    \item \textcolor{red}{vittima}, chiamati flagN(N=00,01,ecc.) rappresentano la vittima e presentano diversi tipi di vulnerabilità
    \item \textcolor{red}{Admin}, amministratore del sistema con credenziali:
    \begin{itemize}
        \item username: nebula
        \item password: nebula
    \end{itemize}
\end{itemize}

Noi accederemo sempre come utente levelN, con l'obiettivo di:
\begin{itemize}
    \item Elevare i privilegi
    \item Ottenere informazioni sensibili
\end{itemize}

Raggiunto l'obiettivo, si cattura la bandierina, per questo motivo le sfide prendono il nome di CTF.

% ------------------ 
% NEBULA LEVEL00
% ------------------ 
\section{Level00}
\subsection{Obiettivo}
Eseguire \textbf{/bin/getflag} con privilegi di \textbf{flag00}.
\subsection{Idea per risolvere la sfida}
Usiamo comando: 
\begin{lstlisting}[style=bashstyle]
    find / -perm /u+s 2>/dev/null | grep flag00
\end{lstlisting}
Tra i vari risultati notiamo il file: 
\begin{lstlisting}[style=bashstyle]
    /bin/.../flag00
\end{lstlisting}
Visualizziamo i metadati del file trovato con il comando:
\begin{lstlisting}[style=bashstyle]
    ls -l
\end{lstlisting} 
Notiamo che è di proprietà di \textbf{flag00} e ha \textbf{SETUID} acceso.
Mandiamo in esecuzione il file con il comando: 
\begin{lstlisting}[style=bashstyle]
    /bin/.../flag00
\end{lstlisting} 
Verremo autenticati come utente flag00 e quindi vinceremo la sfida eseguendo:
\begin{lstlisting}[style=bashstyle]
    /bin/getflag
\end{lstlisting}


% ------------------ 
% NEBULA LEVEL01
% ------------------ 
\section{Level01}
\subsection{Obiettivo}
Eseguire \textbf{/bin/getflag} con privilegi di \textbf{flag01}.
\subsection{Ispezione directory}
Controlliamo le directory \textbf{/home/level01} e \textbf{/home/flag01}. Notiamo che \textbf{/home/flag01} contiene l’eseguibile \textbf{flag01}.
Analizziamo i metadati del file \textbf{flag01} con: 
\begin{lstlisting}[style=bashstyle]
    ls -l
\end{lstlisting}
Si scopre che il file in questione è di proprietà di \textbf{flag01} e ha \textbf{SETUID} acceso.
\subsection{Analisi del sorgente}
\begin{itemize}
    \item Imposta tutti gli user ID al valore effettivo (elevazione dell’utente al valore associato a flag01) 
    \item Imposta tutti i group ID al valore effettivo (elevazione del gruppo al valore associato a level01) 
    \item Esegue un comando, tramite la funzione di libreria \textbf{system():} \begin{lstlisting}[style=cstyle]
        system("/usr/bin/env echo and now what?");
    \end{lstlisting}
\end{itemize}
Leggendo il manuale di \textbf{system()} capiamo che in questa sfida il problema è l’utilizzo della \textbf{system()} in un programma con \textbf{SETUID} acceso, e che giocando con le variabili di ambiente si può violare la sicurezza del programma.
Un altro punto importante è che la \textbf{system()} non funziona correttamente se \textbf{/bin/sh} corrisponde a \textbf{bash}. Quindi controlliamo con il comando: 
\begin{lstlisting}[style=bashstyle]
    ls -l /bin/sh
\end{lstlisting} 
e notiamo proprio che sh punta a bash.

La \textbf{system()} non fa altro che utilizzare sh per eseguire un comando, tale comando viene eseguito da un processo figlio che eredita i privilegi del padre.
Dopodiché \textbf{/usr/bin/env} esegue il comando successivo ovvero echo, quindi per vincere la sfida ci basta inoculare /bin/getflag al posto di echo.

\subsection{Idea per risolvere la sfida}
Copiamo \textbf{/bin/getflag} in una cartella temporanea \textbf{tmp} e diamogli nome \textbf{echo} con il comando: \begin{lstlisting}[style=bashstyle]
    cp /bin/getflag /tmp/echo
\end{lstlisting}
Alteriamo il percorso di ricerca delle variabili d'ambiente in modo da preporre \textbf{/tmp} alla lista delle variabili d'ambiente con il comando: 
\begin{lstlisting}[style=bashstyle]
    PATH=/tmp:$PATH
\end{lstlisting}
Questo è quello che succede:
\begin{itemize}
    \item Il comando env prova a caricare il file eseguibile echo
    \item Poiché echo non ha un percorso assoluto, sh usa i percorsi di ricerca per individuare il file da eseguire 
    \item sh individua /tmp/echo come primo candidato all’esecuzione, dato che l'abbiamo posto per primo
    \item sh esegue /tmp/echo con i privilegi dell’utente flag01
\end{itemize}

\subsection{Sintesi comandi da eseguire}
I comandi da eseguire sul terminale della macchina sono i seguenti:
\begin{lstlisting}[style=bashstyle] 
    # copia getflag in echo
    cp /bin/getflag /tmp/echo
    # aggiorna PATH
    PATH=/tmp:$PATH
    # esegui flag01
    /home/flag01/flag01
\end{lstlisting}
Vinciamo la sfida.

\subsection{Debolezze}
\begin{itemize}
    \item privilegi di esecuzione ingiustamente elevati
    \item versione bash che non abbassa i privilegi di esecuzione
    \item manipolazione variabile PATH
\end{itemize}

\subsection{Mitigazioni}
\begin{enumerate}
    \item Spegnere bit SETUID:
    \begin{itemize}
        \item autenticarsi come root e avviare una shell con il comando: \begin{lstlisting}[style=bashstyle] 
        sudo -i
        \end{lstlisting}
        \item spegnere SETUID con il comando: \begin{lstlisting}[style=bashstyle] 
        chmod u-s /home/flag01/flag01
        \end{lstlisting}   
        \item Eseguiamo flag01 e noteremo che l’attacco non va a buon fine. 
    \end{itemize}
    \item Modificare sorgente level01.c:
    \begin{itemize}
        \item usare putenv() per rimuover /tmp da PATH:
        \begin{lstlisting}[style=cstyle]
        putenv("PATH=/bin:/sbin:/usr/bin:usr/sbin");
        \end{lstlisting}
        \item compiliamo con il comando:
        \begin{lstlisting}[style=bashstyle]
        gcc -o flag01-env level01-env.c
        \end{lstlisting}
        \item impostiamo i privilegi sul nuovo file con:
        \begin{lstlisting}[style=bashstyle]
        chown flag01:level01 /home/flag01/flag01-env 
        chmod u+s /home/flag01/flag01-env   
        \end{lstlisting}
        \item Impostiamo PATH e riproviamo l'attacco
        \begin{lstlisting}[style=bashstyle]
        PATH=/tmp:$PATH  
        \end{lstlisting} 
        \item Eseguiamo flag01-env e noteremo che l’attacco non va a buon fine.
    \end{itemize}   
\end{enumerate}


% ------------------ 
% NEBULA LEVEL02
% ------------------ 
\section{Level02}
\subsection{Obiettivo}
Eseguire \textbf{/bin/getflag} con privilegi di \textbf{flag02}.
\subsection{Ispezione directory}
Controlliamo le directory \textbf{/home/level02} e \textbf{/home/flag02}. Notiamo che \textbf{/home/flag02} contiene l’eseguibile \textbf{flag02}.
Analizziamo i metadati del file \textbf{flag02} con: 
\begin{lstlisting}[style=bashstyle]
    ls -l
\end{lstlisting}
Si scopre che il file in questione è di proprietà di \textbf{flag02} e ha \textbf{SETUID} acceso.

\subsection{Analisi del sorgente}
\begin{itemize}
    \item Imposta tutti gli user ID al valore effettivo (elevazione dell’utente al valore associato a \textbf{flag02}).
    \item Imposta tutti i group ID al valore effettivo (elevazione del gruppo al valore associato a \textbf{level02}).
    \item Alloca un buffer e ci scrive dentro alcune cose, tra cui il valore di una variabile di ambiente (\textbf{USER}).
    \item Stampa una stringa e il contenuto del buffer.
    \item Esegue il comando contenuto nel buffer tramite \texttt{system}.
\end{itemize}
La funzione di libreria \textbf{asprintf()}:
\begin{itemize}
    \item Alloca un buffer di lunghezza adeguata.
    \item Copia una stringa nel buffer utilizzando la funzione \textbf{sprintf()}.
    \item Restituisce il numero di caratteri copiati (e -1 in caso di errore).
\end{itemize}
Nel sorgente level02.c non è possibile usare l’iniezione di comandi tramite PATH. Al contrario di quanto accadeva in level01.c, in level02.c il path del comando è scritto esplicitamente: \textbf{/bin/echo}

\subsection{Idea per risolvere la sfida}
L’idea qui è quella di modificare \textbf{USER} in modo da modificare buffer.
In BASH è possibile concatenare due comandi con il carattere separatore \textcolor{red}{;} quindi: 
\begin{lstlisting}[style=bashstyle]
    echo comando1; echo comando 2
\end{lstlisting}
Impostiamo USER come segue: 
\begin{lstlisting}[style=bashstyle]
    USER='level02; /bin/getflag'
\end{lstlisting}
Se eseguiamo flag02 l’attacco fallisce perché dopo \textbf{/bin/echo level02; /bin/getflag} c’è la stringa \textbf{is cool}
Per evitare questo usiamo il \textcolor{red}{\#} per commentare. 
Quindi sovrascriviamo USER come segue:
\begin{lstlisting}[style=bashstyle]
    USER='level02; /bin/getflag #'
\end{lstlisting}

\subsection{Sintesi comandi da eseguire}
\begin{lstlisting}[style=bashstyle]
    # Modifica variabile USER
    USER='level02; /bin/getflag #'
    # Esegui flag02
    /home/flag02/flag02
\end{lstlisting} 
Vinciamo la sfida.

\subsection{Debolezze}
\begin{itemize}
    \item privilegi di esecuzione ingiustamente elevati
    \item versione bash che non abbassa i privilegi di esecuzione
    \item non vengono neutralizzati i caratteri speciali
\end{itemize}

\subsection{Mitigazioni}
\begin{enumerate}
    \item Spegnere bit SETUID:
    \begin{itemize}
        \item autenticarsi come root e avviare una shell con il comando: \begin{lstlisting}[style=bashstyle] 
        sudo -i
        \end{lstlisting}
        \item spegnere SETUID con il comando: \begin{lstlisting}[style=bashstyle] 
        chmod u-s /home/flag01/flag01
        \end{lstlisting}   
        \item Eseguiamo flag01 e noteremo che l’attacco non va a buon fine. 
    \end{itemize}
    \item Ottenere username corrente con funzioni di libreria o sistema. Modifichiamo quindi il sorgente level02.c con la funzione di sistema\textbf{getlogin()}, che restituisce il puntatore ad una stringa contenete il nome dell’utente che sta lanciando il processo.
    \begin{lstlisting}[style=cstyle]
    char *username; 
    username=getlogin(); 
    asprintf(&buffer, "/bin/echo %s is cool", username);
    \end{lstlisting}
    Compiliamo il nuovo sorgente con:
    \begin{lstlisting}[style=bashstyle]
    gcc -o flag02-getlogin level02-getlogin.c
    \end{lstlisting}
    Impostiamo i privilegi su flag02-getlogin con:
    \begin{lstlisting}[style=bashstyle]
    chown flag02:level02 /path/to/flag02-getlogin 
    chmod 4750 /path/to/flag02-getlogin
    (4750 corrisponde a rwsr-x---)
    \end{lstlisting}
    Eseguiamo flag02-getlogin, non vinciamo la sfida.
    \item Un’altra mitigazione si effettua tramite la funzione \textbf{strpbrk()}. Aggiungiamo nel codice:
    \begin{lstlisting}[style=cstyle]
    const char invalid_chars[] = "!\"$&'()*,:;<=>?@[\\]^`{|}";
    \end{lstlisting}
    e dopo la \textbf{asprintf()}
    \begin{lstlisting}[style=cstyle]
    if ((strpbrk(buffer, invalid_chars)) != NULL) { 
    perror("strpbrk"); 
    exit(EXIT_FAILURE); 
    }
    \end{lstlisting}
\end{enumerate}
Quindi compiliamo e impostiamo i privilegi come per la prima mitigazione ed eseguiamo. La sfida non verrà vinta.

% ------------------ 
% NEBULA LEVEL13
% ------------------ 
\section{Level13}
\subsection{Obiettivo}
\begin{itemize}
    \item Recupero della password (token) dell’utente \textbf{flag13}, aggirando il controllo di sicurezza del programma \textbf{/home/flag13/flag13}.
    \item Autenticazione come utente \textbf{flag13}.
    \item Esecuzione del programma \textbf{/bin/getflag} come utente \textbf{flag13}.
\end{itemize}

\subsection{Ispezione directory}
Controlliamo le directory \textbf{/home/level13} e \textbf{/home/flag13}. Notiamo che \textbf{/home/flag13} contiene l’eseguibile \textbf{flag13}.
Analizziamo i metadati del file \textbf{flag13} con: 
\begin{lstlisting}[style=bashstyle]
    ls -l
\end{lstlisting}
Si scopre che il file in questione è di proprietà di \textbf{flag13} e ha \textbf{SETUID} acceso.

\subsection{Analisi del sorgente}
Viene controllato se UID è diverso da 1000, e in tal caso si stampa un messaggio di errore e si esce dal programma.
Altrimenti viene generato il token e viene stampato a video.

\subsection{Idea per risolvere la sfida}
Usando il comando \textbf{man environ}, scopriamo che alcune variabili di ambiente, tra cui \textbf{LD\_LIBRARY\_PATH}, \textbf{LD\_PRELOAD} possono influenzare il comportamento del linker dinamico, ovvero parte del SO che carica e linka le librerie condivise necessarie a un eseguibile a runtime. 
Scopriamo che \textbf{LD\_PRELOAD} contiene un elenco di librerie condivise (shared object) separato da \textcolor{red}{:}

In particolare \textbf{LD\_PRELOAD} viene utilizzata per ridefinire dinamicamente alcune funzioni (function overriding) senza dover ricompilare i sorgenti.
Possiamo usare la variabile \textbf{LD\_PRELOAD} per caricare in anticipo una libreria condivisa che implementa la funzione del controllo degli accessi del programma \textbf{/home/flag13/flag13}. Questa libreria condivisa va scritta da zero, e in particolare, reimposta getuid() per superare il controllo degli accessi.

Scriviamo il file \textbf{getuid.c}.
Generiamo la libreria condivisa \textbf{getuid.so} con il comando: 
\begin{lstlisting}[style=bashstyle]
    gcc -shared -fPIC -o getuid.so getuid.c
\end{lstlisting}

\begin{itemize}
    \item \textcolor{red}{-shared}: genera un oggetto linkabile a tempo di esecuzione e condivisibile con altri oggetti.
    \item \textcolor{red}{-fPIC}: genera codice indipendente dalla posizione (Position Independent Code), rilocabile ad un indirizzo di memoria arbitrario.
\end{itemize}

Carichiamo in anticipo la libreria condivisa getuid.so modificando la variabile \textbf{LD\_PRELOAD} con il comando:
\begin{lstlisting}[style=bashstyle]
    export LD_PRELOAD=./getuid.so
\end{lstlisting}
Proviamo l'attacco ma fallisce, questo perché, se l'eseguibile è SETUID, deve esserlo anche la libreria condivisa.
La soluzione è quella di rimuovere SETUID da flag13. Questo lo facciamo con una semplice copia tramite il comando:
\begin{lstlisting}[style=bashstyle]
    cp /home/flag13/flag13 /home/level13
\end{lstlisting} 

\subsection{Sintesi dei comandi da eseguire}
\begin{lstlisting}[style=bashstyle]
    # creiamo il file getuid.c
    # compiliamo getuid.c
    gcc -shared -fPIC -o getuid.so getuid.c
    # carichiamo la nuova getuid.so
    export LD_PRELOAD=./getuid.so
    # copiamo flag13 per spegnere SETUID
    cp /home/flag13/flag13 /home/level13
    # eseguiamo flag13 dalla directory level13
    /home/level13/flag13
\end{lstlisting} 
Otteniamo il token (esempio sulla mia macchina: b705702b-76a8-42b0-8844-3adabbe5ac58).
Accediamo con il token come flag13, eseguiamo /bin/getflag e vinciamo la sfida.

\subsection{Debolezze}
\begin{itemize}
    \item Privilegi di esecuzione ingiustamente elevati.
    \item Versione di bash che non abbassa i privilegi di esecuzione.
    \item Manipolazione di una variabile di ambiente (\textbf{LD\_PRELOAD}) per sostituire \textbf{getuid()} con una funzione che aggira il controllo di autenticazione.
    \item Bypass dell'autenticazione tramite spoofing: L'attaccante può riprodurre il token di autenticazione di un altro utente.
\end{itemize}
\subsection{Mitigazioni}
\begin{enumerate}
    \item Spegnere bit SETUID:
    \begin{itemize}
        \item autenticarsi come root e avviare una shell con il comando: \begin{lstlisting}[style=bashstyle] 
        sudo -i
        \end{lstlisting}
        \item spegnere SETUID con il comando: \begin{lstlisting}[style=bashstyle] 
        chmod u-s /home/flag01/flag01
        \end{lstlisting}   
        \item Eseguiamo flag01 e noteremo che l’attacco non va a buon fine. 
    \end{itemize}
    \item Non ha senso ripulire la variabile LD\_PRELOAD come fatto per PATH in level01, perché LD\_PRELOAD agisce prima del caricamento del programma. Infatti nel momento in cui il processo esegue putenv() su LD\_PRELOAD, la funzione getuid() è già stata iniettata da tempo!
    La mitigazione qui è banale, ovvero non rendere noto il valore 1000 all'attaccante.
\end{enumerate}

% ------------------ 
% NEBULA LEVEL4
% ------------------ 


